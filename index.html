<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Duck MST-2 Approximation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            position: relative;
        }
        canvas {
            background-color: #ffffff;
            border: 1px solid #000;
            position: absolute;
            z-index: 0;
        }
        #startButton {
            padding: 30px 100px;
            font-size: 48px;
            cursor: pointer;
            background-color: #0077cc;
            color: white;
            border: none;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
        }
        #info {
            font-size: 50px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 40px 80px;
            border-radius: 5px;
            position: absolute;
            top: 10px;
            left: 10px;
            transform: none;
            white-space: pre-line;
        }
    </style>
</head>
<body>
<button id="startButton">Start</button>
<div id="info">Time: 0s</div>
<canvas id="canvas" width="4400" height="2400"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const duckMotherImg = new Image();
    duckMotherImg.src = 'duckmother.png';

    const babyDuckImg = new Image();
    babyDuckImg.src = 'babyduck.png';

    const NUM_DUCKS = 10;
    const ducks = [];
    let tour = [];
    let currentIdx = 0;
    let animating = false;
    let timerInterval;
    let time = 0;
    let duck = { x: 0, y: 0 };
    const footprints = [];
    const traversedEdges = [];
    let totalDistance = 0;

    const infoDiv = document.getElementById('info');

    function distance(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function generateRandomDucks() {
        ducks.length = 0;
        const margin = 200;
        const minDist = 200;

        while (ducks.length < NUM_DUCKS) {
            const x = Math.random() * (canvas.width - 2 * margin) + margin;
            const y = Math.random() * (canvas.height - 2 * margin) + margin;

            const newDuck = { x, y };
            let tooClose = ducks.some(d => distance(d, newDuck) < minDist);
            if (!tooClose) ducks.push(newDuck);
        }
    }

    function drawGrid() {
        const gridSize = 50;
        ctx.strokeStyle = '#ddd';
        for (let x = 0; x <= canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }

    function drawDucks() {
        ducks.forEach((duck, i) => {
            ctx.drawImage(babyDuckImg, duck.x - 80, duck.y - 80, 100, 100);
        });
    }

    function drawMotherDuck() {
        ctx.drawImage(duckMotherImg, duck.x - 160, duck.y - 160, 200, 200);
    }

    function drawFootprints() {
        ctx.fillStyle = 'gold';
        footprints.forEach(footprint => {
            ctx.beginPath();
            ctx.ellipse(footprint.x - 8, footprint.y, 5, 10, Math.PI / 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(footprint.x + 8, footprint.y, 5, 10, -Math.PI / 6, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawTraversedEdges() {
        ctx.font = 'bold 50px Arial';
        ctx.fillStyle = 'red';
        traversedEdges.forEach(edge => {
            const { from, to, weight } = edge;
            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;
            ctx.fillText(weight.toFixed(1), midX + 10, midY - 10);
        });
    }

    function mstApproximation() {
        const edges = [];
        const visited = Array(NUM_DUCKS).fill(false);

        for (let i = 0; i < ducks.length; i++) {
            for (let j = i + 1; j < ducks.length; j++) {
                const weight = distance(ducks[i], ducks[j]);
                edges.push({ u: i, v: j, weight });
            }
        }

        edges.sort((a, b) => a.weight - b.weight);
        const mst = [];
        visited[0] = true;
        while (mst.length < NUM_DUCKS - 1) {
            for (const edge of edges) {
                if (visited[edge.u] && !visited[edge.v]) {
                    mst.push(edge);
                    visited[edge.v] = true;
                    break;
                }
                if (visited[edge.v] && !visited[edge.u]) {
                    mst.push(edge);
                    visited[edge.u] = true;
                    break;
                }
            }
        }

        const tour = [];
        function dfs(node, parent) {
            tour.push(node);
            mst.forEach(edge => {
                if (edge.u === node && edge.v !== parent) dfs(edge.v, node);
                if (edge.v === node && edge.u !== parent) dfs(edge.u, node);
            });
        }
        dfs(0, -1);
        return tour.concat(0);
    }

    function animate() {
        if (!animating) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawDucks();
        drawFootprints();
        drawTraversedEdges();
        drawMotherDuck();

        const target = ducks[tour[currentIdx]];
        const dx = target.x - duck.x;
        const dy = target.y - duck.y;
        const dist = Math.hypot(dx, dy);
        const speed = 6;

        if (dist > speed) {
            duck.x += dx / dist * speed;
            duck.y += dy / dist * speed;

            if (
                footprints.length === 0 ||
                Math.hypot(duck.x - footprints[footprints.length - 1].x, duck.y - footprints[footprints.length - 1].y) > 20
            ) {
                footprints.push({ x: duck.x, y: duck.y });
            }
        } else {
            if (currentIdx < tour.length - 1) {
                const from = ducks[tour[currentIdx]];
                const to = ducks[tour[currentIdx + 1]];
                const weight = distance(from, to);
                traversedEdges.push({ from, to, weight });
                totalDistance += weight;
            }

            currentIdx++;
            if (currentIdx >= tour.length) {
                animating = false;
                clearInterval(timerInterval);
                infoDiv.textContent = `Time: ${time}s\nTotal Distance: ${totalDistance.toFixed(1)}`;
                return;
            }
        }

        requestAnimationFrame(animate);
    }

    document.getElementById('startButton').addEventListener('click', () => {
        if (animating) return;

        animating = true;
        generateRandomDucks();
        tour = mstApproximation();
        currentIdx = 0;
        duck = { ...ducks[tour[0]] };
        time = 0;
        totalDistance = 0;
        footprints.length = 0;
        traversedEdges.length = 0;

        infoDiv.textContent = 'Time: 0s';
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            time++;
            infoDiv.textContent = `Time: ${time}s`;
        }, 1000);

        animate();
    });

    let loadedCount = 0;
    [duckMotherImg, babyDuckImg].forEach(img => {
        img.onload = () => {
            loadedCount++;
            if (loadedCount === 2) {
                drawGrid();
                generateRandomDucks();
                drawDucks();
            }
        };
    });
</script>
</body>
</html>
