<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Greedy TSP Animation with Shipper and Time Complexity</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh;
      margin: 0;
      text-align: center;
    }
    canvas {
      background-color: #f8f8f8;
      position: relative;
      margin-top: 20px;
    }
    #time-complexity {
      font-size: 16px;
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 8px;
      box-shadow: 1px 1px 5px rgba(0,0,0,0.2);
      z-index: 10;
      position: absolute;
      top: 10px;
    }
    #start-btn {
      font-size: 16px;
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 10;
      margin-top: 20px;
    }
    #start-btn:hover {
      background-color: #45a049;
    }
    h2 {
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h2>Greedy TSP Animation with Shipper</h2>
<canvas id="tspCanvas" width="1600" height="800"></canvas>

<button id="start-btn">Start Animation</button>
<div id="time-complexity">Time complexity: O(n²)</div>

<script>
// Canvas setup
const canvas = document.getElementById('tspCanvas');
const ctx = canvas.getContext('2d');

// Load shipper image
const shipperImg = new Image();
shipperImg.src = "shipper.png"; // File ảnh để cùng thư mục với html

// Base house coordinates
const baseHouses = [
  [0.0, 75.0], [225.0, 75.0], [75.0, 225.0], [75.0, 0.0], [225.0, 0.0],
  [300.0, 300.0], [300.0, 150.0], [150.0, 0.0], [75.0, 150.0], [150.0, 75.0]
];

// Random points for decoration
const randomPoints = [];
for (let i = 0; i < 15; i++) {
  randomPoints.push([Math.random() * 300, Math.random() * 300]);
}

// Scale for canvas
const offsetX = 50;
const offsetY = 50;
const scale = 1.2;

// Euclidean distance
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  return Math.sqrt(dx * dx + dy * dy);
}

// Greedy TSP algorithm
function greedyTSP(coords) {
  const n = coords.length;
  const visited = Array(n).fill(false);
  const path = [0];
  visited[0] = true;

  for (let step = 0; step < n - 1; step++) {
    let last = path[path.length - 1];
    let nextCity = -1;
    let minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (!visited[i]) {
        const dist = distance(coords[last], coords[i]);
        if (dist < minDist) {
          minDist = dist;
          nextCity = i;
        }
      }
    }
    path.push(nextCity);
    visited[nextCity] = true;
  }
  path.push(0); // return to starting point
  return path;
}

// Draw points (houses + random points)
function drawPoints(houses) {
  houses.forEach((house, index) => {
    ctx.beginPath();
    ctx.arc(house[0] * scale + offsetX, canvas.height - house[1] * scale - offsetY, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    ctx.closePath();
    ctx.font = "12px Arial";
    ctx.fillStyle = 'black';
    ctx.fillText(index, house[0] * scale + offsetX + 8, canvas.height - house[1] * scale - offsetY + 4);
  });

  randomPoints.forEach((point) => {
    ctx.beginPath();
    ctx.arc(point[0] * scale + offsetX, canvas.height - point[1] * scale - offsetY, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'green';
    ctx.fill();
    ctx.closePath();
  });
}

// Shuffle function (Fisher-Yates)
function shuffleArray(array) {
  let shuffled = array.map(p => [...p]); // Deep copy
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Variables
let houses = [];
let path = [];
let currentSegment = 0;
let t = 0;
let animating = false;

// Start button event
document.getElementById("start-btn").addEventListener("click", function() {
  if (animating) return; // Nếu đang chạy animation thì không bấm tiếp
  animating = true;
  
  currentSegment = 0;
  t = 0;
  
  // Shuffle houses
  houses = shuffleArray(baseHouses);
  
  // Clear canvas and redraw
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPoints(houses);
  
  // Measure time
  let startTime = performance.now();
  path = greedyTSP(houses);
  let endTime = performance.now();
  let elapsedTime = (endTime - startTime) / 1000;
  
  updateTimeComplexity(elapsedTime);
  
  animate();
});

// Update time complexity display
function updateTimeComplexity(elapsedTime) {
  let complexityElement = document.getElementById("time-complexity");
  let target = `Time complexity: O(n²) (n = ${baseHouses.length}) - Time: `;
  let current = 0;
  clearInterval(complexityElement.intervalId);

  complexityElement.intervalId = setInterval(function() {
    if (current < elapsedTime) {
      current += 0.01;
      complexityElement.innerText = `${target}${current.toFixed(2)}s`;
    } else {
      clearInterval(complexityElement.intervalId);
      complexityElement.innerText = `${target}${elapsedTime.toFixed(2)}s`;
    }
  }, 30);
}

// Animate shipper moving
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPoints(houses);

  ctx.beginPath();
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  for (let i = 0; i < currentSegment; i++) {
    const start = houses[path[i]];
    const end = houses[path[i + 1]];
    ctx.moveTo(start[0] * scale + offsetX, canvas.height - start[1] * scale - offsetY);
    ctx.lineTo(end[0] * scale + offsetX, canvas.height - end[1] * scale - offsetY);
  }
  ctx.stroke();
  ctx.closePath();

  if (currentSegment < path.length - 1) {
    const start = houses[path[currentSegment]];
    const end = houses[path[currentSegment + 1]];

    const x = (1 - t) * start[0] + t * end[0];
    const y = (1 - t) * start[1] + t * end[1];

    ctx.beginPath();
    ctx.strokeStyle = 'purple';
    ctx.moveTo(start[0] * scale + offsetX, canvas.height - start[1] * scale - offsetY);
    ctx.lineTo(x * scale + offsetX, canvas.height - y * scale - offsetY);
    ctx.stroke();
    ctx.closePath();

    ctx.drawImage(shipperImg, x * scale + offsetX - 30, canvas.height - y * scale - offsetY - 30, 60, 60);

    t += 0.02;
    if (t >= 1) {
      t = 0;
      currentSegment++;
    }
    requestAnimationFrame(animate);
  } else {
    ctx.drawImage(shipperImg, houses[path[0]][0] * scale + offsetX - 30, canvas.height - houses[path[0]][1] * scale - offsetY - 30, 60, 60);
    animating = false;
  }
}
</script>

</body>
</html>
